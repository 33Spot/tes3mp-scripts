## Introduction
So here's my attempt at dumping a bunch of information I know about tes3mp in the hopes it helps people to understand how it works. I'm a scripter, I like scripts, therefore most of the stuff I know (and by extension, what'll be written in this guide) will be skewed fairly heavily towards a scripter's perspective of things. Consider this a somewhat basic view of *general tes3mp stuff* with some more detailed information of the scripting side of things, though this won't be a scripting tutorial or anything like that. It's also not complete or anything like that - I may add to or edit stuff later on to make this more of a complete guide. Or I may not, who knows?

I don't know everything about tes3mp, and what I do know might be wrong, so you should bear that in mind as you read through this (and message me with corrections!). Also, since tes3mp is in constant development and subject to change, anything I write here that's *correct* might at some point become *incorrect* :P


*This version of the guide was written during 0.7-alpha*
## What is ~cloud gaming~ tes3mp?
Apparently, tes3mp isn't a Morrowind multiplayer mod. It's a *mod*ification to an engine that's being made to run *Morrowind* called OpenMW (the MW referring to *Morrowind*). The *mod*ifications that tes3mp provide to this engine called Open*Morrowind* allow people to play *Morrowind* with other players (i.e. in a *multiplayer* fashion). One could perhaps summarise that tes3mp is a *Morrowind multiplayer mod*, and use the correct terminology to describe how it is different from an *Elder Scrolls plugin* or the like that one would use with the old Gamebryo version of Morrowind. But nah.  
Okay, I might be being a *little* bit facetious here :P. The main interesting thing to take away from this is that sometime in the future OpenMW, and by extension tes3mp, might branch out to being able to load assets from and run later Bethesda games (at which point I reckon they'd have to rebrand - I'm placing my bets on "OpenES" and "tesXmp", even if that does completely ignore the Fallout games).

## The Client, The Server, and The ***LUA SCRIPTS***
There are three magic components that make tes3mp all work: The Client, The Server, and The Lua Scripts (technically the Server and the Lua scripts are kinda both part of the server, but I'm treating them separately for the purposes of this explanation):
* **The Client** - The Client runs pretty much the same as it does when you play Morrowind (on OpenMW), it loads up all the Morrowind assets, plugins, etc. and runs the game. It's in charge of effectively everything related to the game and its logic, playing out the game and relaying important information to the server for it to handle as it needs to ("hey, I went through this door to here" (I activated the object with id x and travelled to cell y), "hey, I just removed my trousers" (unequipped my item in slot x), "hey, I just dropped my trousers on the floor" (placed an object with the id x in the cell y at position z), "hey, a rat spawned here" (a creature with id x spawned in cell y at position z (+more because it's an actor)). What the client doesn't know is how the world is supposed to differ from its starting state - it's effectively like it's always launched without a save file. The server acts like a shared save file, telling the client how it needs to change from its starting state to be up to date, as and when it needs to.
* **The Server** - The Server is dumb. It doesn't know *anything* about how the game actually works, it simply acts as a relay of information between The Client and The Lua Scripts. When Client A drops their trousers in the Balmora Mages Guild, its the job of the Server to tell any other clients that there are now trousers littering up the fine establishment and where, as well as informing The Lua Scripts in case they want to know, and to also add the information to the server save (OKAY, technically this isn't quite how it goes down - in actuality it's: The Client says that it's placed trousers to The Server -> The Server tells The Lua Scripts that it's been told by The Client that it's placed trousers -> The Lua Scripts think to themselves for a bit -> The Lua Scripts then tell The Server to tell the other clients about Client A's disregard for closets -> The Server tells the other clients about the placed trousers). Remember, though, that The Server is dumb - it doesn't know what any of this game stuff means. All it knows is that somebody supposedly placed an item with an id "common_pants_01" at a certain coordinate, in a place called "Balmora, Guild of Mages", which it only knows by name because some clients have mentioned that they've been there. It leaves The Client to interpret what that means - "'common_pants_01'? Oh, so there's a pair of 'Common Pants' on the lower bunk of this bed. I know that these use *this* model, and *this* texture, are worth 4 gold, weigh 2, etc...".
* **The Lua Scripts** - The Lua Scripts are where a lot of the server-side logic happens, including the saving of information, and are where most of the modifications for how the server works can be made by scripters. When The Server receives information from The Client, it can trigger certain bits of The Lua Scripts to run (an event) (see `serverCore` section). There are some parts of The Server code that are exposed for The Lua Scripts to utilise, which it can use to access information from The Server, as well as make The Server perform certain actions. Here's a breakdown of how the trouser example would go down: Client tells The Server about placing the trousers; The Server triggers the event `OnObjectPlace` in The Lua Scripts; As part of the base Lua Scripts, The Lua Scripts ask The Server to tell it more about the event "What item?" etc.; Some Lua Scripts magic happens that I won't go into much detail about yet (this step includes saving the placed item!); The Lua Scripts tell The Server (using those exposed bits of code) to tell The Client(s) that the trousers have been placed; The Server does just that. Because the code for The Lua Scripts is all available to be edited, scripters can change anything about what happens inside it. If we wanted to, with a simple edit we could change it so when a player drops those trousers, they get upgraded into expensive pants, or with a slightly more advanced edit, we could make a cliff racer spawn to punish the player for making a mess. Of course, it's worth noting that The Lua Scripts are equally as dumb as The Server - they know nothing about the game beyond some ids, it's up to the scripters to provide them with any extra information they might need. In addition to (or as part of) The Lua Scripts logic, they are also in charge of saving/loading all the changes that have been made to the world, so that they can be relayed to The Clients (via The Server) when needed. They keep track of each change, storing them as a sort of set of instructions, which are saved to files using the `jsonInterface`. We'll get more into just how that works in the Saving + Loading section.
Because of the way The Server interfaces with The Lua Scripts, Lua Scripts are largely reactionary (triggering off events), and limited by the sorts of events and Server-linked functions that are available.

## The Big Files and what they do (serverCore, logicHandler, eventHandler)
### Server Core
`serverCore` is the most important part of the server-lua connection, being the main interface between the two. It's responsible for loading up everything required for lua related stuff, as well as most of the things outlined in `config`. It's also where all of the events are first triggered via the server, though for many of these events the actual logic for processing them is passed off to `eventHandler`. For example, when a player uses an item, their client sends the related packet to the server, the server then triggers the `OnPlayerItemUse` function inside `serverCore` so that lua scripts can begin being executed (technically, `OnPlayerItemUse` is more complicated than this, but I'm just grabbing a random event to use as a basic example).

### Logic Handler
`logicHandler`, perhaps unsurprisingly, handles a lot of the server-side logic. Its uses vary from loading cell data into the `LoadedCells` table (see The Important Variables), to coordinating that process for a player, to creating an object at a location, or formatting a player's name to print to chat, or doing the dirty to ban a player. `logicHandler` is worth reading through to see what useful functions are already available within it if you're working on a script.

### Event Handler
In keeping with aptly-named modules, `eventHandler` is where event-based logic is handled. Remember that it's in `serverCore` that the server initially triggers lua-side event stuff, during which the `serverCore` event functions then trigger the respective `eventHandler` functions. Inside the `eventHandler` functions, the lua code utilises some of the exposed Server code to get details concerning the event that triggered it. For example, in `eventHandler.OnObjectPlace` the function uses `tes3mp.GetObjectRefId(index)` to learn the placed object's `refId`.

### Tangent: How Events Work
Here's a breakdown of an event as it unfolds:
* The Client sends a packet of information to The Server
* The Server causes the appropriate `serverCore` function to run, based on the packet
* The `serverCore` function causes the appropriate `eventHandler` function to run
* Using exposed functions from The Server (see Resources), the `eventHandler` function queries information from The Server about the last appropriate packet(?) that it received (ObjectList/ActorList etc.). Since the lua code runs immediately after The Server receives a packet, this "last appropriate packet" will be the one containing the information on what triggered the event.

**Q:**
* **Why do some events do their logic inside loops?** - For the most part, this is because that event can contain information for multiple things within the packet, like `ActorList`s. There are some events that only contain one thing within the packet, yet still have loops implemented in the lua code. This is mostly future-proofing - just because it only contains one item now, doesn't mean it always will in the future.

## The Important Variables
While there is a lot available for scripters to use, there are some important variables that'll come up often that I'll briefly go into here. Note that most of these are similar in name to some variables declared in `serverCore`, but are distinctly different.
### Players
`Players` is a table that contains the Player Class Instances of all the players who are currently online. It's initially setup in `logicHandler`, but since it's global it is available everywhere. The Player information is stored inside `Players` using the online player's `pid`(see How Players Work) as the key (note that while `pid`s are numbers, the Players table isn't an indexed table and shouldn't be treated as such). The standard method of accessing an online player's Player information is to use `Players[pid]`. A Player is first assigned to a player's pid (and added to the Players table) during `eventHandler.OnPlayerConnect`, with an existing player's data being loaded into the Player during `eventHandler.OnGUIAction`'s `if idGui == guiHelper.ID.LOGIN then` section.


*See also: How Players Work*
### LoadedCells
`LoadedCells` is a table containing the Cell Class Instances of all the cells that are currently loaded by the server (by default, this means any cell that is loaded by a player). It's initially setup in `logicHandler`, but since it's global it is available everywhere. The Cell information is stored inside `LoadedCells` using the cell's `cellDescription` (see How Cells Work) as the key. The standard method of accessing a cell's Class information is to use `LoadedCells[cellDescription]`. A Cell instance is assigned to `LoadedCells` during `logicHandler.LoadCell`.


*See also: How Cells Work*
### WorldInstance
`WorldInstance` is the only Instance of the World as it is loaded by the server. It's initially setup in `logicHandler`, but since it's global it is available everywhere.


*See also: How The World Works*
### RecordStores
(Custom Records are a recent addition that I need to put a bit more effort into learning before trying to explain them. I guess I could mention that RecordStores is related to them, though :p)

## Saving + Loading (Plus Client Memory and Server Memory)
There have been a few mentions on how some of the saving/loading stuff works in tes3mp (and will be more later), but we'll go over it again here in the interest of keeping everything relevant to it in one place. The Client - that is, the things players launch to run and play the game on - doesn't save any information about the world, it effectively starts every session with a fresh save file. The Server (and The Lua Scripts) are in charge of recording every change that happens as a result of The Clients playing the game, and so serves like a special sort of save file. As and when The Client needs to know, The Server will relay every change that The Client has to make to its world to be in synch with all the other player (*when* they need to know varies on the type of information, which we'll probably get onto later). The data is stored by The Lua Scripts using `json` formatting (with the config option `config.databaseType` allowing for `sqlite3` format, although it's not fully implemented) within the `mp-stuff\data` folder, with each major type then being added to its own folder within `data` (e.g. `mp-stuff\data\cell` for cell data, `mp-stuff\data\player` for player data). For the purposes of further explaining the nuances of all this stuff, I'm going to be using some terms that I'll define here (note: I don't know if these are the *proper* terms, but they're what I'll be using :P):
* **Client Memory** - Anything that's been loaded by The Client.
* **Server Memory** - Any information currently held by The Server or The Lua Scripts.
* **Saved Data** - The contents of stuff in `json` files - anything that's actually been written into a file.

### Client Memory
The Client Memory holds all the information that The Client has loaded about how the game normally is, as well as how it was told to deviate from its base state to match up with the server. It only holds this information for the duration of its play Session, forgetting everything after it's closed/disconnected. The exact times/ways that each type of data is loaded varies. While the specifics of each will be in their own dedicated section, I'll mention them here also:
* Basically every change that one player makes is sent to every other player. If one player places an object in the Balmora Mages Guild, the instruction to place that object is sent to every player on the server, regardless of whether the other players are currently in the cell, have previously loaded the cell during their current Session, or are yet to load the cell during their current Session. The same applies to many things such as journal updates, depending on how the server has been configured. Noteworthy things this includes: basically every change to a cell, the creation of new custom records.
* When a player logs in/creates a character, they're sent the world's time and weather, as well as the world's shared information on journal entries, faction ranks, topics, etc. depending on the configuration of the server (otherwise, they load that information from their own player file)
* When a player enters a cell *for the first time that Client Session*, they are sent a list of instructions about how to alter the cell to make it fit with the server's version of the cell. (see `scripts\cell\base.lua`s `AddVisitor`)
* *Any time* the player enters a cell, the server ensures they have the information for any custom records linked to it, and also sends "Momentary Cell Data" (the position + stats of actors in the cell, if there are any).  (see `scripts\cell\base.lua`s `AddVisitor`)
* *Also any time* when a player enters a cell, the server will ensure that the entering player has all the information for the custom records associated with every other player in the cell, and that every other player in the cell will have all the information for the entering player's associated custom records (by associated custom records I mean anything currently associated with them like spells, carried items, etc. rather than literally every custom record that they've made). The logic for this is done in `logicHandler.ExchangeGeneratedRecords`, which is triggered in `eventHandler.OnPlayerCellChange`.

### Server Memory
The Server Memory holds a mixture of things for the duration that The Server is run in a Session. It retains information of the most recent packets its received (I don't know if it retains anything more than the most recent of its type or not). It also holds all of the information for The Lua Scripts, like variables, tables, etc. At times, The Lua Scripts will load Saved Data into the Server Memory, and are also responsible for adding some data from Server Memory into Saved Data. Basically everything Lua Script related deals with information held within Server Memory.

### Saved Data
Saved Data comes in the form of `json` files saved in the `mp-stuff\data` directory. The information inside them isn't more than a lua table that's been saved from the Server Memory in the form of a `json` file via The Lua Scripts. The data stored in these files are later loaded from the `json` files and into the Server Memory, again by The Lua Scripts. This is used by the main scripts to store all the changes that players have made for later Server Sessions.

**Q:**
**My script has made changes to somethings data, but when I check that things `json` file I don't see the changes! Why?** - 
Assuming the script is actually working, this is might just be a problem with expectations. When a script makes changes to the data tables of something, the changes are made to the lua table that's in *Server Memory*. The `json` file is effectively a snapshot of what's currently held in the lua table *at the time it was told to be saved*, so the `json` will almost always be behind on reflecting what's *actually* in the Server Memory if it hasn't been told to save the moment the changes happened. Things such as Cells and Players have triggers in The Lua Scripts to save their `json`s at appropriate times to minimize spam while also making sure not to miss saving data (see their sections for specifics), though if you really must you can always trigger one to save within your script.

### Saving/Loading for Scripts
There are a couple of supported ways for you to save information for your scripts, and which one you choose varies based on your scripts requirements, as well as a bit of personal preference. Both of these methods of saving involve saving the contents of a lua table into a file, and loading that information back from a file into a lua table.

The first is the "official" method - `customVariables`. `customVariables` is a table that appears in the data for a number of Classes - Player, Cell, and World. The idea is for scripts to insert their own variables/tables into it for storing information pertinent to that particular instance, so a Player's `customVariables` would be used to store information that's about a player, a Cell's `customVariables` for something to do with that Cell, and the World's `customVariables` for storing information about the World, or just simply general information. The fact that a Player or Cell needs to be loaded in order to access its `customVariables` tables somewhat limits the sort of information that you can store there, meaning that often even variables concerning Players or Cells might end up saved in the Worlds `customVariables`, since that's always available. To utilise the `customVariables` for saving information: Add whatever information you want to the `customVariables` table. If required, trigger the `Save` method for whatever you're saving the information to (generally this would be `Player[pid]:Save()` for Players; `LoadedCells[cellDescription]:Save()` for Cells; `WorldInstance:Save()` for the World).

The second method is to utilise the `jsonInterface` which is used be The Lua Scripts for saving data like Players and Cells, and use it to save your own custom `json` files for your scripts. It works effectively the same way, it's just requires a tiny bit of code to save/load. You'd use this method over the`customVariables` method when:
* The script will be operating in an environment where the appropriate World, Player, or Cell file(s) may be deleted from another source, and the information you want to save needs to persist beyond the file's deletion
* When you want information from the script to be available to other programs to utilise, since `json` is quite a well supported format that can be loaded by many languages. For example, the online player map made by TeamFOSS used a `json` to periodically save the positions of online players, which was loaded by entirely different code on the website side to display where they were on the online map.
* When you might be storing a lot of information and want to keep the normal data files tidy :P

#### Player Names and pids
When storing information about a Player (outside of the Players `customVariables`), you'll need to use their name as a way as identifying them, since `pid`s vary from login. I forget the specifics, but it's the case that one/some of a player's `.name`, .`.login.name`, `.accountName` can vary between logins, because the name entered can vary in capitilzation from the player's "true" name. Therefore, it's best to convert the players name into all lowercase when using it for storage/comparisons.

## Objects - Data File Objects and Multiplayer Objects
All Objects have a unique identifier that sets it apart from all other objects (for referencing them in scripts, etc.), this identifier is known as the `uniqueIndex` (before 0.7, this was called a `refIndex` instead). Examples include "0-1569", "299510-0". There are two types of Object: Data File Object and Multiplayer Object, but before I get around to explain what they are I should briefly explain what an Object is...
### What is an Object?
An Object is basically everything that has some physical manifestation within the game world, and as such is only really relevant to the realm of Cells. Buildings, doors, walls, containers, actors, etc. are all forms of Objects, and exist within Cells. Items *that are placed in the world* (and so have a physical manifestation), rather than placed in inventories, are Objects. Items inside inventories *aren't* Objects (since they only exist as pieces of information). This distinction means that while items placed in the world will have a `uniqueIndex`, those inside inventories won't (again, because the former is an Object, while the latter isn't).
### Data File Objects and Multiplayer Objects
So back to Data File Objects and Multiplayer Objects... You'll notice in the `uniqueIndex` examples that I gave, the `uniqueIndex` is formed of two numbers separated by a `-`. You might also notice that in each example, the number on one side is 0. This is true for all `uniqueIndex`es, and is how we tell whether it belongs to a Data File Object, or a Multiplayer Object - for Data File Objects, the 0 is in the second half (and the actual id in the first), and for Multiplayer Objects, the 0 is in the first half (and the actual id in the second). So what's the difference between the two and why are they relevant?
* **Data File Objects** - Data File Objects are the Objects that have been placed in the world as determined by the client's Data Files (their `.esp`s and `.esm`s). The ID that a Data File Object is given is based on the order it is placed in the Data Files (meaning the load order of Data Files can affect the ID that it's given). The only time Data File Objects will pop up in a Cell's data is to record how a player's actions have changed them from its default state, for example when a player picks up an item that was placed by the editor, the server will make a record to tell every player to delete that item when they load that Cell (simplification for sake of example). **Important Note:** Because Data File Object IDs are based on the load order, you *should not* change the load order of any plugins that place Objects without wiping *all* Cell data first, or else risk bad stuff happening. As a basic example, say that the 1000th loaded object is a loaf of bread. A player picks up that bread, and so in the Cell's data, the instruction "Delete the 1000th loaded object" is stored. If the load order is now changed so that the 1000th loaded object happens to be Mr. Vitally Important to a Quest, anyone loading the Cell the bread was taken from will receive the instruction "Delete the 1000th loaded object", which'll mean deleting Mr. Vitally Important to a Quest. (This example is a relatively tame example, I think if actors are involved it might actually lead to data corruption).
* **Multiplayer Objects** - Multiplayer Objects are any Objects that weren't initially placed by the Data Files. This includes things such as every item a player places on the ground, any creature spawned in via random means (so those that interrupt a rest, or spawn from a levelled creature node - *not* creatures that were placed manually in the editor). The ID that a Multiplayer Object is assigned is based on a variable called `currentMpNum` that's stored in World. The variable records the last number the scripts assigned to a Multiplayer Object, and each time a new Multiplayer Object is generated, that number is increased by one, and that new number is used as the Multiplayer Object's ID (its `mpNum`). **Important Note:** Because Multiplayer Object IDs are determined by the `currentMpNum` variable in World, if ever resetting the World file while keeping *any* Cell data, you *must* preserve the `currentMpNum` and place it in the new World file. Otherwise you'll get conflicts with multiple objects using the same `uniqueIndex`, with much the same problems as messing with the order of Data Files for Data File Objects.

## How Cells Work
Rather than explain what a Cell is normally in Morrowind, I'm going to just assume everyone already knows, and just straight right ahead to how they differ/specifically how they work in tes3mp. The way we differentiate Cells is by their `cellDescription`, which is effectively just their name as it appears in game (for exterior cells, it's their region coordinates). The Client has a starting idea of what a Cell is supposed to be like based on what it's loaded from the Data Files into its Client Memory. The job of The Sever (and The Lua Scripts) is to record every change a player makes to a Cell so it can tell The Client what changes it has to make in its Client Memory to "load" The Server's version of that Cell.

### What happens when a Player enters a Cell
Cells are probably one of the most complex and important parts to how the whole game works that rather than try and break everything apart (which I will kinda do later), I'm going to roughly lay out what happens when a Cell is loaded in one big chunk, so we can get an idea of the scope...

When The Client tries to enter a Cell, they send the Cell's `cellDescription` (basically, the name of the Cell) to The Server. The Server then triggers the `OnCellLoad` event in `serverCore`, which in turn triggers the `eventHandler` version (see: How Events Work), and *that* ultimately just hands everything off to `logicHandler.LoadCellForPlayer` (from this point onwards I'm just going to be describing the effects of everything done rather than the specific functions run because there are quite a few of them :P). The steps break down into the following:
* There's a check to see if the Cell is currently loaded by The Lua Scripts (by checking if it's in the `LoadedCells` table). If it *isn't:*
	* If The Lua Scripts can't find a save file for that Cell, a new entry is created
	* The Cell's data is loaded via The Lua Scripts into the LoadedCell
* If the Cell *is* loaded:
	* The positions and stats of the Actors (the momentary data) in the Cell are saved
* The player is entered as a visitor to the Cell. This includes adding their `pid` to the Cell's `visitors` table, as well as adding the cell to the *Player's* `cellsLoaded` table.
* If the Player hasn't entered the Cell during their Client Session, then they're made to load all the data for the Cell. This is done with a bunch of the Cell's functions and using the information stored in the Cell's `objectData` and `packets` data. Note why the Player shouldn't have to load the Cell's data if they have been there during their Client Session: The first time they loaded the Cell gave them the servers changes into their Client Memory, and the packets of information that they've been receiving (effectively) via the other Clients about every change since (remember, basically all changes to the world are broadcast to everyone, even if they aren't in the Cell that its about) should have kept them in synch.
* If the Cell doesn't have any information about the containers inside it, it'll request that information from The Client (remember, The Server doesn't know anything about the game and is reliant on The Client to tell it things). Just like in normal Morrowind, the player's client generates the contents of all inventories (containers and actor inventories) - a lot of these items are set by the data files, however some items (levelled items) have to be randomly generated at this time (again, this is just normal Morrowind behaviour). The player's client then sends all that information to the server. (I believe prior to 0.7, the contents of containers were instead only sent to and recorded by the server on a need-to-know basis, only occurring when a player first opens a container that the server doesn't have information on.)
* Very much the same happens then for Actors: if there isn't any info on the Actors, The Client is queried for a list of the `uniqueIndex`es and `refId`s for all the Actors in the Cell.
* The Player is given the momentary data to load (actor positions + stats). Because either the Cell has just been loaded, or the loaded Cell had just had its momentary data saved, this information will always be up to date.
* The Cell Authority is assigned. If there isn't an authority, then the entering Player is made it. If there *is* a current authority, there are checks to see if the entering player has a better ping than the current cell authority. If the entering player has a ping that is better by the value set in the server config (pingDifferenceRequiredForAuthority) (default: 40), then they are made the new authority.

### Loaded Cells (nothing to do with LoadedCells)
Perhaps obviously, the player who is inside an Interior Cell has that Cell loaded. Less obviously, a player outside in an *Exterior Cell* will have the Exterior Cell chunk that they're in loaded, as well as every *adjacent* exterior chunk (for a total of 9 Cells). I don't know how the likes of fake Exterior Cells such as the outside areas of Mournhold are treated in tes3mp (they're Interior Cells with a special flag set in the editor so the game treats them like Exterior Cells, giving them weather and stuff), though from a quick glance at the base Cell Class, it *looks* like a Cell will only have the `isExterior` variable set to true if its name matches the Exterior Cell naming pattern (which Mournhold doesn't), though I can't say if the same is true of the other functions.

### LoadedCells (*everything* to do with Loaded Cells)
As mentioned in the section "The Important Variables", `LoadedCells` is a table that contains information on all the server-versions of the Cells loaded into Server Memory. It's important for The Lua Scripts because this is the main way that they mess with Cell-related stuff. I figured I'd just re-mention it here since this is the Cell section.

### The Cell Authority
I don't fully understand the nuances of The Cell Authority to really explain it, only about how its managed (see: above). I know it's something to do with whose client is in charge of the Cell's Actors, namely their AI(?).

### objectData
Each data entry for Cells contains a table called `objectData`. This table holds the information concerning all the Objects that it has information about. At minimum, this'll be a table containing the Objects `refId` under the key `refId`, stored inside `objectData` using the Objects `uniqueIndex` as a key.

### Packets
Every time The Server receives information from The Client, it makes a record of everything it will have to tell The Clients that join later on in order to have their Client Memory reflect the changes. Each packet table is an indexed table, where the related Objects `uniqueIndex` is inserted as a value. This information on its own, however, isn't usually enough - in addition to adding an entry to the right packet table, The Lua Scripts also add additional required information to the Objects `objectData` entry. What is added varies from packet to packet. (Note: If you're adding stuff with scripts, you may have to be doing these parts yourself, depending on how you're implementing it).
* **delete** - Instructions to delete a Data File Object. This won't be present for Multiplayer Objects (`place`d or `spawn`ed), because instead of recording the instruction to remove said Object, the instructions to create said Objects are removed.
* **place** - Instructions to place an Object (ostensibly a Multiplayer Object). For placing Actors, `spawn` is used instead. The addition of a `location` table is added to the Objects `objectData`, containing the Objects `posX`, `posY`, `posZ`, `rotX`, `rotY`, and `rotZ` information (basically, it's coordinates). There are a few other pieces of information that are also added if they deviate from the default values: `count` (the number of items in the stack), `charge` (the durability), `enchantmentCharge` (...the enchantment charge), `soul` (iunno, something related to souls), `goldValue` (the number of coins in a stack of gold).
* **spawn** - Instructions to spawn an Actor. As with `place`, a `location` table is added to the Objects `objectData` table. Additionally, if the Actor is a summon, a table called `summon` is added, containing `duration` (the duration of the summon spell?) and `startTime` (the `os.time()` that it was summoned). If the Actor was summoned by a player, an entry called `summonerPlayer` (the account name of the summoning player) is also included in the `summon` table.
* **lock** - Instruction to *change* the lock information of an Object from its default value. An entry called `lockLevel` (the lock level of the lock) is added to the Object's `objectData`.
* **trap** - Records when a trap has been triggered that was initially on a Data File Object (?)
* **scale** - Instructions to scale an Object. An entry called `scale` (the number to scale the object by) is added to the Object's `objectData`.
* **state** - I think this is for whether or not an Object is enabled/disabled? An entry called `state` (the enabled/disabled state?) is added to the Object's `objectData`.
* **doorState** - Records whether a door is open/closed. An entry called `doorState` (either 1/2, though I don't know which means open and which means closed :P) is added to the Objects `objectData`.
* **container** - Records of items contained within an Object (could be a static like a chest, or an actor like a rat). A table called `inventory` is added to the Objects `objectData`. The `inventory` table is an indexed table which holds tables containing information on each item inside the container. The entries in these tables are `refId` (the item's refId), `count` (the number of items in the stack), `charge` (the durability), `enchantmentCharge` (the enchantment charge), `soul` (again, I dunno exactly what this is, something to do with souls).
* **equipment** - Records what's currently equipped on an Actor. A table called `equipment` is added the the Objects `objectData`. The `equipment` table is a keyed table that uses the equipment's slotId for keys, holding tables that contain some information of the items equipped. The entries in these tables are `refId` (the items refId), `count` (the number of items in the stack), `charge` (the durability of the item), and `enchantmentCharge` (the enchantment charge).
* **ai** - (This is recent and more complicated than the rest of them, so I'll need more time to fully learn about it before teaching it :P)
* **death** - Records that an Actor should be dead. If the Actor was killed by another Actor (?), or a player, the table `killer` is added to the Objects `objectData`. If the killer was a player, then the entry `player` (the player's account name) is added to the `killer` table. If the killer was an Actor, the Actor's `refId` (their refId :v), and `uniqueIndex` (their uniqueIndex :V) are added to the `killer` table.
* **actorList** - Records that an Actor exists.
* **position** - Records the position of an Actor. Like `place`, a table called `location` is added to the Objects `objectData`, containing the Actor's `posX`, `posY`, `posZ`, `rotX`, `rotY`, and `rotZ` information. I guess this means that it'll overwrite the location provided by `spawn`, if the Actor was spawned.
* **statsDynamic** - Records the basic stats of an Actor. A table called `stats` is added to the Actors `objectData`, containing information on the Actors stats: `healthBase` (their base max health), `healthCurrent` (their current health), `healthModified` (their modified max health?), `magickaBase` (their base max magicka), `magickaCurrent` (their current magicka), `magickaModified` (their modified max magicka?), `fatigueBase` (their base max fatigue), `fatigueCurrent` (their current fatigue), and `fatigueModified` (their modified max fatigue?).
* **cellChangeTo** - Records that a Data File Actor has moved from this starting Cell to a new one. An entry called `cellChangeTo` (the cellDescription of the cell the Actor was moved to) is added to the Objects `objectData` (*after* the rest of its data is transferred to that new Cell).
* **cellChangeFrom** - Records that a Data File Actor has come from a different Cell. An entry called `cellChangeFrom` (the cellDescription of the Actor's original Cell) is added to the Objects `objectData`.

### Saving Cells
Normally, a Cell's data is saved whenever:
* A Player leaves the Cell
* A Player who has the Cell loaded disconnects (basically the same as the first :P)

### Generally Useful Variables
* **visitors** - It's an an indexed table, containing the `pid` of every player inside it.
* **customVariables** - Like Players and the World, each Cell has its own section for scripts to store custom data concerning each Cell specifically.

## How Players Work
There's a stupid amount of stuff that's handled with Players - basically *everything* player-facing goes in it, including but not limited to: their name, location, skills, attributes, stats, inventory, equipment, spells, journal, *books they've read*, *and their quick keys*. There's so much stuff that I'm going to cop-out for now and leave it to future-me to write everything up, or use this as an opportunity to get those interested looking through the Base Player Class file (see: Resources) to see everything it has :p
### Player ID
When The Client connects, The Server assigns them an identifier to differentiate them from other players currently online, called a Player ID (which is often referred to as `pid` in the scripts, etc.). The number they're assigned is the lowest number that isn't currently in use, starting at 0. It's worth noting that while multiple players can't share a `pid` at the same time, multiple players could have the same `pid` across the Servers Session if the player who was previously assigned the `pid` disconnected and another player joined later and was assigned it. What I'm basically saying is that a `pid` should only be used to identify a player if the thing that needs to happen to them is happening *right that moment*.

### Generally Useful Variables
There are a great deal of things that I could cover about Players, but most of them are quite obvious as to what they do. Instead, I think it's good to mention a few more obscure/potentially useful things as a quick infodump:
* **cellsLoaded** - `cellsLoaded` is a table attached to the Player Instance that keeps track of every Cell that the Player has loaded. It's an indexed table, containing the `cellDescription` of the Cell as its values.
* **initTimestamp** - Tracks the `os.time()` value that the Player Instance was created (i.e. when the Player was loaded). Useful if you want to gauge what sort of information they might have in their Client Memory.
* **customVariables** - Like Cells and the World, each Player has their own section for scripts to store custom data concerning each player specifically.
* **recordLinks** - Might be worth mentioning. Used to keep track of all the Generated Records associated with the Player.


## How The World Works
Oh man, a topic of *that* scope is probably too much for this tutorial. Instead, I guess I'll just talk about what World means/is/does in tes3mp ;P The World is in charge of storing and cooridnating all the less physical information about the game world, like the time, weather, what NPCs have died. Depending on how the server has been configured, it also manages the "shared" values for things like everyone's journal entries, faction positions, reputation, etc.
### Mp Num
As mentioned in the Objects section, one of the things World is responsible for is storing the `currentMpNum` - an identifier used when creating server objects to ensure that each of their `uniqueIndex`es are... unique. The same important note mentioned in that section still applies: **Important Note:** Because Multiplayer Object IDs are determined by the `currentMpNum` variable in World, if ever resetting the World file while keeping *any* Cell data, you *must* preserve the `currentMpNum` and place it in the new World file. Otherwise you'll get conflicts with multiple objects using the same `uniqueIndex`, with much the same problems as messing with the order of Data Files for Data File Objects.

## How Actors Work
(I need to do more research on how Actors work before I write about them. What I can say is that they basically exist as a subsection of Cells)

## Custom Records
(Custom Records are a recent addition that I need to put a bit more effort into learning before trying to explain them)

## Regions
(Regions are a recent addition that I need to put a bit more effort into learning before trying to explain them. There's some stuff about exterior cells, and players being given Region authorities to control weather synch)

## RESOURCES
The best way to actually learn about how everything works is by reading through what already exists of the main tes3mp code. Second (or maybe equally as good?) is to ask questions to people who know more about it - there's an entire channel (#scripting-help) in the [official discord server](https://discordapp.com/invite/ECJk293) dedicated to scripting questions.
### CoreScripts
You can find all The Lua Script sided stuff in either your downloaded `mp-stuff\scripts` folder, or [online here](https://github.com/TES3MP/CoreScripts/tree/0.7.0/scripts). Use the "branch" dropdown near the top left to select your desired version. The things with Classes (cells, players, world, recordStore) have their own folders, wherein you can find the basic Class Methods (the things you call with `:SomeFunction()`) for each of them within the `base.lua` file. Reading through these and the contents of `scripts` is the best way to learn how everything works.
### The Exposed Server Functions
You can find what I refer to the "exposed server functions" (the bits you call with `tes3mp.*`) [listed here](https://github.com/TES3MP/openmw-tes3mp/tree/0.7.0/apps/openmw-mp/Script/Functions). Use the "branch" dropdown near the top left to select your desired version. The files ending in `.hpp` contain a list of all related Server Functions, along with comments on how they work. It's better to understand how these actually work by seeing how they're used in the `CoreScripts` for context.
### Quick Lookup
Sometimes you're doing something in a particular area, and need to know where to check to read up on how stuff related to it is implemented in the code for reference. Here's a few quick pointers of what files you should probably consult for each topic:
* **Cells** - `cell\base` (contains the vast majority of cell-stuff), `eventHandler` (namely the cell-related events), `logicHandler` (is ultimately in charge of the loading/unloading of cells for players, etc.)
* **Players** - `player\base` (contains the vast majority of player-stuff), `eventHandler` (there are a lot of events that are ultimately linked to  players), `logicHandler` (lots of player-related logic)
* **Actors** - `cell\base` (all (?) Actor stuff is a subset of Cells), `eventHandler` (the Actor events)
